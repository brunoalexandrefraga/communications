---
title: Propagação em Larga Escala - Parte 2
subtitle: Laboratório 07
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
  Este trabalho tem por objetivo consolidar a técnica de projeto de redes de casamento de impedância, em especial a técnica pela rede L. Para isso, é proposto realizar o casamento de impedância da saída de um amplificador para uma carga de 50 $\Omega$ de modo que a eficiência da potência dissipada na carga seja de 80%. Após algumas análises o projeto foi concluído com sucesso e realizada uma simulação Monte Carlo com 100 iterações para verificar a robustez do projeto por técnicas estatísticas. Os resultados obtidos foram brevemente discutidos.
keywords: 
  - Robustez
  - Adaptação de impedância
  - Análise estatística
date: last-modified
bibliography: bibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}

          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: RF Circuits
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

# Tarefa 1

## Introdução



## Resolução

```{python}
#| echo: false
import scipy
import numpy as np

# Parâmetros
freq_T1 = 1.8e9  # Hz
Pt_T1 = 2e-3  # W
d0_T1 = 1  # m
Gt_T1 = 1  # adimensional
Gr_T1 = 1  # adimensional

# Comprimento de onda
_lambda_T1 = scipy.constants.c / freq_T1

# Potência recebida
Pr_d0_T1 = (Pt_T1 * Gt_T1 * Gr_T1) * (_lambda_T1 / (4 * scipy.constants.pi * d0_T1))**2

# Conversão para dBm
Pr_d0_T1_dBm = 10 * np.log10(Pr_d0_T1 / 1e-3)

d_T1 = 200

```

```{python}
#| echo: false
def format(value):
    if value >= 1e9:
        return f"{value / 1e9:.2f} G"
    elif value >= 1e6:
        return f"{value / 1e6:.2f} M"
    elif value >= 1e3:
        return f"{value / 1e3:.2f} k"
    elif value >= 1:
        return f"{value:.2f} "
    elif value >= 1e-3:
        return f"{value * 1e3:.2f} m"
    elif value >= 1e-6:
        return f"{value * 1e6:.2f} μ"
    elif value >= 1e-9:
        return f"{value * 1e9:.2f} n"
    elif value >= 1e-12:
        return f"{value * 1e12:.2f} p"
    elif value >= 1e-15:
        return f"{value * 1e12:.2f} p"
    else:
        return f"{value:.0e} "
```

```{python}
#| echo: false
def format_simple(value, decimals=2):
    format_string = f"{{:.{decimals}f}}"
    return f"{format_string.format(value)}"
```

Para a frequência de `{python} format(freq_T1)`Hz, obtém-se $\lambda=$ `{python} format(_lambda_T1)`m. Dada a equação da perda por propagação no espaço livre @goldsmith2020wireless

$$
  \frac{P_r}{P_t}=G_tG_r\left[\frac{\lambda}{4\pi d}\right]^2
$$

Supondo a distância de referência, $d_0=$ `{python} format(d0_T1)`m, e ganhos para as antenas de transmissão, $G_t=$ `{python} Gt_T1`, e recepção, $G_r=$ `{python} Gr_T1`, obtém-se $P_r=$ `{python} format_simple(Pr_d0_T1_dBm)` dBm. Com esse valor, é possível calcular o modelo de perda de propagação do tipo log-distância para calcular $P(d)$, com $d=$ `{python} format_simple(d_T1)` m, utilizando a equação

$$
  P_r(d)=P_r(d_0)-10n\log\left(\frac{d}{d_0}\right)
$$

Em que $n$ é o valor que minimiza a equação quadrática de diferença entre as potências medida, $P_{r_m}$, e calculada, $P_{r}$.

$$
  F(n)=\sum_{i=1}^{n}\bigg[P_{r_m}\left(d_i\right)-P_{r}\left(d_i\right)\bigg]^2
$$

Para realizar essa minimização, utiliza-se a tabela fornecida pelo problema

```{python}
#| echo: false
#| label: tbl-distance-power
#| tbl-cap: "Potência medida em diferentes distâncias"
#| output: asis

# Dados da tabela
dados = [
    {"i": 1, "Distância (m)": 10, "Medição (dBm)": -65},
    {"i": 2, "Distância (m)": 20, "Medição (dBm)": -72},
    {"i": 3, "Distância (m)": 50, "Medição (dBm)": -87},
    {"i": 4, "Distância (m)": 100, "Medição (dBm)": -105},
    {"i": 5, "Distância (m)": 300, "Medição (dBm)": -128},
]

# Cabeçalhos
cabecalhos = "| i | Distância (m) | Medição (dBm) |\n"
linha_divisoria = "|---|---------------|---------------|\n"

# Formatação da tabela
tabela = cabecalhos + linha_divisoria
for linha in dados:
    tabela += f"| {linha['i']} | {linha['Distância (m)']} | {linha['Medição (dBm)']} |\n"

# Exibe a tabela em Markdown
print(tabela)
```

See @tbl-distance-power.

```{python}
#| echo: false
  Pr_d_T1_dBm = Pr_d0_T1_dBm - 10 * np.log10(d_T1/d0_T1)
```

Dessa forma, a 

que 


































# References {-}

---
title: Propagação em Larga Escala - Parte 2
subtitle: Laboratório 07
author:
  - name: Bruno Alexandre Fraga
    email: bruno.fraga@posgrad.ufsc.br
    affiliations: 
        - id: some-tech
          name: Universidade Federal de Santa Catarina
          department: Departamento de Engenharia Elétrica e Eletrônica
          address: R. Delfino Conti
          city: Florianópolis
          state: Santa Catarina
          postal-code: 88040-370
abstract: |
  Este trabalho tem por objetivo consolidar a técnica de projeto de redes de casamento de impedância, em especial a técnica pela rede L. Para isso, é proposto realizar o casamento de impedância da saída de um amplificador para uma carga de 50 $\Omega$ de modo que a eficiência da potência dissipada na carga seja de 80%. Após algumas análises o projeto foi concluído com sucesso e realizada uma simulação Monte Carlo com 100 iterações para verificar a robustez do projeto por técnicas estatísticas. Os resultados obtidos foram brevemente discutidos.
keywords: 
  - Robustez
  - Adaptação de impedância
  - Análise estatística
date: last-modified
bibliography: bibliography.bib
format:
  elsevier-pdf:
    include-in-header:
      - text: |
          \usepackage{steinmetz}
          \usepackage[a4paper, margin=1in]{geometry}
          \usepackage{graphicx} % Required for inserting images
          \usepackage{circuitikz}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{amsthm}
          \usepackage{comment}

          \newcommand{\parallelsum}{\mathbin{\!/\mkern-5mu/\!}}
    keep-tex: true
    journal:
      name: RF Circuits
      formatting: preprint
      # model: 3p # Don't set a model with preprint
      cite-style: number
---

# Tarefa 1

## Introdução



## Resolução

```{python}
#| echo: false
import scipy
import numpy as np

# Parâmetros
freq_T1 = 1.8e9  # Hz
Pt_T1 = 2e-3  # W
d0_T1 = 1  # m
Gt_T1 = 1  # adimensional
Gr_T1 = 1  # adimensional

# Comprimento de onda
_lambda_T1 = scipy.constants.c / freq_T1

# Potência recebida
Pr_d0_T1 = (Pt_T1 * Gt_T1 * Gr_T1) * (_lambda_T1 / (4 * scipy.constants.pi * d0_T1))**2

# Conversão para dBm
Pr_d0_T1_dBm = 10 * np.log10(Pr_d0_T1 / 1e-3)

d_T1 = 200

```

```{python}
#| echo: false
def format(value):
    if value >= 1e9:
        return f"{value / 1e9:.2f} G"
    elif value >= 1e6:
        return f"{value / 1e6:.2f} M"
    elif value >= 1e3:
        return f"{value / 1e3:.2f} k"
    elif value >= 1:
        return f"{value:.2f} "
    elif value >= 1e-3:
        return f"{value * 1e3:.2f} m"
    elif value >= 1e-6:
        return f"{value * 1e6:.2f} μ"
    elif value >= 1e-9:
        return f"{value * 1e9:.2f} n"
    elif value >= 1e-12:
        return f"{value * 1e12:.2f} p"
    elif value >= 1e-15:
        return f"{value * 1e12:.2f} p"
    else:
        return f"{value:.0e} "
```

```{python}
#| echo: false
def format_simple(value, decimals=2):
    format_string = f"{{:.{decimals}f}}"
    return f"{format_string.format(value)}"
```

Para a frequência de `{python} format(freq_T1)`Hz, obtém-se $\lambda=$ `{python} format(_lambda_T1)`m. Dada a equação da perda por propagação no espaço livre @goldsmith2020wireless

$$
  \frac{P_r}{P_t}=G_tG_r\left[\frac{\lambda}{4\pi d}\right]^2
$$

Supondo a distância de referência, $d_0=$ `{python} format(d0_T1)`m, e ganhos para as antenas de transmissão, $G_t=$ `{python} Gt_T1`, e recepção, $G_r=$ `{python} Gr_T1`, obtém-se $P_r=$ `{python} format_simple(Pr_d0_T1_dBm)` dBm. Com esse valor, é possível calcular o modelo de perda de propagação do tipo log-distância para calcular $P(d)$, com $d=$ `{python} format_simple(d_T1)` m, utilizando a equação

$$
  P_r(d)=P_r(d_0)-10n\log\left(\frac{d}{d_0}\right)
$$

Em que $n$ é o valor que minimiza a equação quadrática de diferença entre as potências medida, $P_{r_m}$, e calculada, $P_{r}$.

$$
  F(n)=\sum_{i=1}^{n}\bigg[P_{r_m}\left(d_i\right)-P_{r}\left(d_i\right)\bigg]^2
$$

Para realizar essa minimização, utilizam-se os valores apresentados pela tabela fornecida pelo problema

```{python}
#| echo: false
#| label: tbl-distance-power
#| tbl-cap: "Potência medida em diferentes distâncias"
#| output: asis

# Vetores de dados
dist_T1 = [10, 20, 50, 100, 300]
Pmeas_T1 = [-65, -72, -87, -105, -128]

# Cabeçalhos
header = "| i | Distância (m) | Pmedido (dBm) |\n"
div = "|---|---------------|---------------|\n"

# Formatação da tabela
table = header + div
for i, (d, p) in enumerate(zip(dist_T1, Pmeas_T1), start=1):
    table += f"| {i} | {d}            | {p}           |\n"

# Exibe a tabela em Markdown
print(table)
```



```{python}
#| echo: false
#| output: asis

from sympy import symbols, simplify, log, latex, N
import numpy as np

# Dados
Pr_d0_T1_dBm = -34
d_T1 = 200
d0_T1 = 200
dist_T1 = [10, 20, 50, 100, 300]
Pmeas_T1 = [-65, -72, -87, -105, -128]

# Definir variáveis simbólicas
n = symbols('n')

# Funções
def Pr_d_T1_dBm_calc(d_i):
    return Pr_d0_T1_dBm - 10 * n * log(d_i / d0_T1, 10)

def Fn_partial_calc(Pr_meas_i, d_i):
    return Pr_meas_i - Pr_d_T1_dBm_calc(d_i)

# Calcular Fn
Fn = 0  # Inicializar Fn
for d_i, Pr_meas_i in zip(dist_T1, Pmeas_T1):
    Fn += Fn_partial_calc(Pr_meas_i, d_i)**2

# Simplificar e arredondar
Fn_simplified = simplify(Fn)
Fn_printed = N(Fn, 2)
Fn_rounded = N(Fn_simplified, 2)

# Converter para LaTeX
Fn_latex_original = latex(Fn_printed)
Fn_latex = latex(Fn_rounded)

# Exibir no formato esperado
print(f"$$\n{Fn_latex_original}\n$$")
print(f"$$\n{Fn_latex}\n$$")
```

Dessa forma, a 

que 


































# References {-}
